# 基本介绍
    网站正由网页模式进化到webapp模式，每一个视图要通过异步的方式加载，给前端开发的流程和资源组织带来了巨大的挑战。

    资源是通过增量加载的方式运行在浏览器端

**模块系统主要解决模块的定义、依赖和导出**

    对比：Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。

    原始单个文件顺序加载时，如果把每个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，不同模块的接口调用都是在一个作用域中。这种方式的问题：
        +、全局作用域下容易造成变量冲突
        +、文件只能按照<script>的书写顺序加载
        +、开发人员必须主观解决模块和代码库的依赖关系
        +、在大型项目中各种资源难以管理，导致代码库混乱不堪

# 对比

### CommonJs
    +、同步的加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的
    +、不能在浏览器端不能非阻塞的并行加载多个模块

### AMD
    优点：
        +、适合在浏览器环境中异步加载模块
        +、可以并行加载多个模块
    缺点：
        +、模块定义方式的语义不顺畅，代码的阅读和书写比较困难
        +、不符合通用的模块化思维方式，是一种妥协的实现
    实现：requirejs、curl

### CMD
    规范和AMD很类似，并与CommonJs和Node.js的Modules规范保持了很大的兼容性
    优点：
        +、依赖就近
        +、可以很容易的在Node.js中运行
    缺点：
        +、依赖spm打包，模块的加载逻辑偏重
    实现：seajs,coolie

### UMD

### ES6模块
    ES6增加了js语言层面的模块体系定义。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。
    优点：
        +、容易进行静态分析
        +、面向未来的ES标准
    缺点：
        +、原生浏览器还没有实现该标准
        +、全新的命令字，新版的Node.js才支持
    实现：babel 

## **期望的模块系统**
    可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅是js的模块化，还有css，字体，图片等资源也需要模块化。

    前端模块要在客户端执行，所以他们需要**增量加载**到浏览器中

    模块的加载和传输，我们首先能想到两种极端的方式：
        一、每个模块文件都单独请求，显而易见，会造成请求次数过多，导致应用启动速度慢，
        二、把所有模块打包成一个文件然后请求一次，但是一次请求所有模块造成流量浪费，初始化过程慢。
        总结：这两种方法都过于简单粗暴！

    分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才比较合理
    要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析，编译打包的过程。

    那么，如何做到让require能加载各种资源呢？包括css等。。。？
    A: 在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们的依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如把less转为css模块，再通过css模块把他插入到页面的<style>标签中执行

    ？？同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们需要一个模块加载的兼容策略，来避免重写所有的模块？？ 不懂。。orz

# 关于Webpack

## 一、重复的轮子

    **Webpack是一个模块打包器，它根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。**

    目前已有的模块化工具并不能很好的完成如下的目标：
        +、将依赖树拆分成按需加载的模块
        +、初始化加载的耗时尽量少
        +、各种静态资源都可以视作模块
        +、将第三方库整合成模块的能力
        +、可以自定义打包逻辑的能力
        +、适合大项目，无论是单页还是多页的web应用

    Webpack和其他模块化工具有什么区别吗？

### 代码拆分

    webpack有两种组织模块依赖的方式：同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。

### Loader

    webpack本身只能处理原生的js模块，但是loader转换器可以将各种类型的资源转换成js模块。这样，任何资源都可以成为webpack可以处理的模块了。

### 智能分析

    Webpack有一个智能解析器，几乎可以处理任何第三方库，无论他们的模块形式是CommonJs、AMD还是普通的js文件。甚至在加载依赖的时候，允许使用动态表达式require("./template" + name + ".jade")

### 插件系统

    webpack还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的Webpack插件。

### 快速运行

    webpack使用异步的I/O和多级缓存提高运行效率，这使得webpack能够快速增量编译。

**Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。**

**webpack简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分为三大块**

    entry 入口文件 让webpack用哪个文件作为项目的入口

    output 出口 让webpack把处理完成的文件放在哪里

    module 模块 要用什么不同的模块来处理各种类型的文件









